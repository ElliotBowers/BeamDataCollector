import json
import numpy as np
from scipy import sparse
from scipy.integrate import cumulative_trapezoid
from scipy.sparse.linalg import spsolve
import matplotlib.pyplot as plt
import pandas as pd

# Calculate the baseline using Asymmetric Least Squares Smoothing (ALS)
def als_baseline(y, lam=1e6, p=0.01, niter=10):
    L = len(y)
    D = sparse.diags([1, -2, 1], [0, -1, -2], shape=(L, L - 2))
    w = np.ones(L)
    for _ in range(niter):
        W = sparse.spdiags(w, 0, L, L)
        Z = W + lam * D.dot(D.T)
        A = Z.tocsr()
        z = spsolve(A, w * y)
        w = p * (y > z) + (1 - p) * (y < z)
    return z

def als_baseline_corrected(z):
    baseline = als_baseline(z)
    corrected = z - baseline
    return {
        'corrected': json.dumps(corrected.tolist())
    }

def squarify(y):
    _, corrected, peak_value, left_index, right_index = get_prereqs(y)
    corrected[left_index:right_index + 1] = peak_value
    corrected[right_index:] = 0
    corrected[:left_index] = 0
    return {
        'squarified': json.dumps(corrected.tolist())
    }
    

def width(y):
    left, right = get_prereqs(y)[3:]
    return {
        'width': right - left
    }


def current(y, sampling_rate=5_000_000, f_corner=250, peak_fraction=0.9):
    corrected = get_prereqs(y, sampling_rate, f_corner)[1]

    peak_index = np.argmax(corrected)
    peak_value = corrected[peak_index]
    threshold = peak_fraction * peak_value

    # Define top region: points above threshold
    top_indices = np.where(corrected >= threshold)[0]

    if len(top_indices) == 0:
        raise ValueError("No values found above threshold; check pulse shape or threshold level.")

    avg_current = np.mean(corrected[top_indices])
    # pulse_width = len(top_indices)
    # total_charge = avg_current * pulse_width / sampling_rate  # A Ã— s = Coulombs

    return {
        'current': round(float(avg_current), 4),
        # 'duration': round(pulse_width / sampling_rate, 6),  # in seconds
        # 'charge': round(total_charge, 6),  # in Coulombs
    }


def intensity(y):
    _, corrected, _, left_index, right_index = get_prereqs(y)
    my_range = right_index - left_index
    ten_percent = int(my_range * 0.1)
    start = max(left_index - ten_percent, 0)
    end = min(right_index + ten_percent, len(corrected))

    y_slice = corrected[start:end]
    x_vals = np.arange(len(y_slice))

    area = np.trapezoid(y=y_slice, x=x_vals)
    return {
        'intensity': round(float(area), 3)  # ensure clean Redis output
    }


def mode_filter(signal, window_size=3):
    s = pd.Series(signal)
    filtered = s.rolling(window=window_size, center=True, min_periods=1)\
                .apply(lambda x: x.mode().iloc[0])
    return filtered.to_numpy()




def get_prereqs(y, sampling_rate=5_000_000, f_corner=4000):
    droop = droop_correct(y, sampling_rate, f_corner)
    smoothed = mode_filter(droop, window_size=5)
    baseline = als_baseline(smoothed)
    corrected = smoothed - baseline

    peak_index = np.argmax(corrected)
    peak_value = corrected[peak_index]
    half_max = 0.5 * peak_value

    left_index = peak_index
    while left_index > 0 and corrected[left_index] > half_max:
        left_index -= 1

    right_index = peak_index
    while right_index < len(corrected) - 1 and corrected[right_index] > half_max:
        right_index += 1

    # Plot
    plt.figure(figsize=(10, 5))
    plt.plot(y, label='Original Signal')
    # plt.plot(droop, label='After Droop Correction', linestyle='--')
    # plt.plot(smoothed, label='Mode Filtered', linestyle='-.')
    # plt.plot(baseline, label='Baseline', linestyle=':')
    plt.plot(corrected, label='Final Corrected', linewidth=2)
    plt.axvline(x=left_index, color='r', linestyle='--', label='Left Index')
    plt.axvline(x=right_index, color='g', linestyle='--', label='Right Index')
    plt.axhline(y=peak_value, color='orange', linestyle='--', label='Peak Value')
    plt.title('Signal Processing Flow')
    plt.xlabel('Sample Index')
    plt.ylabel('Amplitude')
    plt.legend()
    plt.grid()
    plt.show()
    return baseline, corrected, peak_value, left_index, right_index




def droop_correct(y, sampling_rate=5_000_000, f_corner=250):
    dt = 1 / sampling_rate
    droop_const = 2 * np.pi * f_corner

    # Cumulative integral of the signal
    integral = cumulative_trapezoid(y, dx=dt, initial=0)

    # Apply correction
    corrected = y + droop_const * integral

    # Optional: shift to start near 0
    corrected -= np.min(corrected)

    return corrected


def extract_signal_from_binary(fields):
    """Extracts the first binary field and converts it into a NumPy array of int16."""
    for value in fields.values():
        if isinstance(value, bytes):
            try:
                # Interpret the byte string as little-endian int16 values
                data = np.frombuffer(value, dtype='<i2')
                return data
            except Exception as e:
                print(f"Error decoding binary field: {e}")
                continue
    raise ValueError("No valid binary signal data found in stream entry.")


def measure(r, in_key, callback, out_key):
    """Continuously stream from Redis using XREAD and apply a processing callback."""
    last_id = '$'  # '$' starts from new entries
    while True:
        print("Listening for data...")
        entries = r.xread({in_key: last_id}, block=1000, count=1)
        if entries:
            print("Got entries...")
            for stream_name, messages in entries:
                for msg_id, fields in messages:
                    try:
                        y = extract_signal_from_binary(fields)  # <- updated to binary
                        result = callback(y)  # Must return a dictionary
                        r.xadd(out_key, result, maxlen=10)
                        last_id = msg_id  # move forward in the stream
                        print(f"Processed entry {msg_id} from {in_key}")
                    except Exception as e:
                        print(f"Error processing entry {msg_id}: {e}")


def process_pulse(y):
    baseline, corrected, peak_value, left_index, right_index = get_prereqs(y)

    flattened = corrected.copy()
    flattened[left_index:right_index + 1] = peak_value
    flattened[:left_index] = 0
    flattened[right_index:] = 0
    rectified = flattened + baseline

    pulse_width = int(right_index - left_index)
    current = peak_value
    intensity = current * pulse_width

    return {
        'signal': json.dumps(rectified.tolist()),
        'current': round(current, 4),
        'intensity': round(intensity, 4),
        'width': pulse_width
    }







if __name__ == "__main__":
    bin = "\xb9\x02\xde\x02\xe4\x02\xe5\x02\xed\x02\xdd\x02\xe9\x02\xe1\x02\xf2\x02\xf1\x02\xf9\x02\xe2\x02\xee\x02\x02\x03\xf4\x02\xeb\x02\xee\x02\xf9\x02\xf2\x02\x00\x03\xf6\x02\xfe\x02\x05\x03\xf8\x02\a\x03\xf1\x02\x03\x03\xfb\x02\xe1\x02\xea\x02\xf6\x02\xec\x02\xf4\x02\xf0\x02\xe3\x02\xe7\x02\xe6\x02\xf0\x02\xeb\x02\xf5\x02\xec\x02\xcd\x02\xeb\x02\xd3\x02\xdb\x02\xd4\x02\xd5\x02\xd9\x02\xc6\x02\xc7\x02\xcb\x02\xd2\x02\xbe\x02\xb0\x02\xb4\x02\xc4\x02\xbe\x02\xa6\x02\x9a\x02\xa2\x02\x95\x02\xb7\x02\x98\x02\x89\x02\x8d\x02\x8c\x02\x92\x02\x90\x02\x85\x02\x81\x02r\x02r\x02m\x02\\\x02Q\x02R\x02J\x02[\x02<\x02B\x029\x02.\x02\x19\x02\x1b\x02&\x02\x1b\x02\x06\x02\x02\x02\xfe\x01\xf3\x01\xe7\x01\xe7\x01\xdf\x01\xda\x01\xd3\x01\xd1\x01\xc7\x01\xb3\x01\xb4\x01\x91\x01\xb5\x01\xa1\x01\x86\x01\x9d\x01\x81\x01h\x01x\x01h\x01m\x01k\x01K\x013\x01=\x01.\x011\x01$\x01\x1b\x01\x1d\x01\t\x01\xef\x00\xed\x00\xea\x00\xde\x00\xc2\x00\xca\x00\xbe\x00\xb6\x00\xb2\x00\xa7\x00\x90\x00\x7f\x00\x84\x00z\x00d\x00e\x00W\x00@\x00A\x00+\x00\x11\x00 \x00\x12\x00\x01\x00\xec\xff\xf1\xff\xec\xff\xd3\xff\xce\xff\xc9\xff\xbc\xff\xb2\xff\x9c\xff\xa7\xff\x8a\xff\x87\xff{\xff\\\xfff\xff_\xffS\xff>\xffC\xff8\xff.\xff\n\xff\x1c\xff\x0f\xff\x00\xff\xeb\xfe\xe7\xfe\xd8\xfe\xcc\xfe\xc4\xfe\xbf\xfe\xae\xfe\x9d\xfe\x8b\xfe\x94\xfe\x86\xfe\x8a\xfea\xfeU\xfeQ\xfeD\xfe'\xfe \xfe\x0b\xfe\x12\xfe\b\xfe\x01\xfe\xeb\xfd\xce\xfd\xd3\xfd\xbb\xfd\xac\xfd\xa1\xfd\x9a\xfd\x8a\xfd\x80\xfdk\xfdX\xfda\xfdO\xfd@\xfd2\xfd\x1d\xfd\a\xfd\x05\xfd\xf8\xfc\xe8\xfc\xd7\xfc\xd7\xfc\xc0\xfc\xae\xfc\xa3\xfc\x97\xfc\x90\xfcz\xfcs\xfcg\xfc<\xfcF\xfc.\xfc\x1b\xfc\x0c\xfc\xf6\xfb\xff\xfb\xe8\xfb\xda\xfb\xc4\xfb\xb7\xfb\x96\xfb\xa4\xfb\x88\xfbn\xfbk\xfbe\xfbW\xfb8\xfb8\xfb,\xfb\x18\xfb\x0b\xfb\xed\xfa\xe8\xfa\xe5\xfa\xb6\xfa\xb3\xfa\xb7\xfa\xa5\xfa\x89\xfaw\xfao\xfad\xfaU\xfa<\xfaE\xfa \xfa\x10\xfa\b\xfa\xfc\xf9\xe2\xf9\xdd\xf9\xcf\xf9\xb5\xf9\xa9\xf9\xa2\xf9\x94\xf9\x80\xf9o\xf9b\xf9H\xf9Y\xf9>\xf9%\xf9$\xf9\x02\xf9\xf8\xf8\xe5\xf8\xdb\xf8\xd0\xf8\xb5\xf8\xad\xf8\x9f\xf8\x82\xf8r\xf8o\xf8N\xf8T\xf87\xf8/\xf8!\xf8\t\xf8\xf7\xf7\xec\xf7\xe8\xf7\xd5\xf7\xb1\xf7\xac\xf7\x9c\xf7\xab\xf7\x90\xf7\x84\xf7T\xf7U\xf7N\xf7<\xf7\x1d\xf7\x13\xf7\x14\xf7\x11\xf7\xec\xf6\xe3\xf6\xcf\xf6\xc1\xf6\xb6\xf6\xb3\xf6\xa1\xf6\x93\xf6{\xf6r\xf6I\xf6G\xf6=\xf60\xf6\x19\xf6\x12\xf6\t\xf6\xe7\xf5\xf1\xf5\xe1\xf5\xcc\xf5\xc5\xf5\xad\xf5\x9b\xf5\x97\xf5~\xf5\x82\xf5d\xf5R\xf5Y\xf5@\xf5(\xf5)\xf5\x03\xf5\xfe\xf4\xf2\xf4\xce\xf4\xcd\xf4\xc3\xf4\xb2\xf4\xb3\xf4\x9b\xf4\x8a\xf4}\xf4v\xf4]\xf4\\\xf4K\xf40\xf4!\xf4#\xf4\x16\xf4\x03\xf4\xf0\xf3\xdd\xf3\xdc\xf3\xc9\xf3\xc3\xf3\xa7\xf3\xa2\xf3\x93\xf3\x86\xf3~\xf3g\xf3g\xf3Z\xf3<\xf35\xf3\"\xf3\x03\xf3\x02\xf3\xf9\xf2\xe2\xf2\xdb\xf2\xec\xf2\xcf\xf2\xb3\xf2\xb2\xf2\xac\xf2\x8e\xf2\x8a\xf2p\xf2c\xf2N\xf2\\\xf28\xf22\xf2\x1e\xf2\x12\xf2\n\xf2\xee\xf1\xef\xf1\xe7\xf1\xcd\xf1\xb7\xf1\xb8\xf1\xaf\xf1\x9b\xf1\x89\xf1v\xf1q\xf1r\xf1Z\xf1S\xf13\xf1C\xf1\r\xf12\xf1\xfa\xf0\xff\xf0\xf0\xf0\xfb\xf0\xe4\xf0\xcf\xf0\xc1\xf0\xaf\xf0\xa1\xf0\x93\xf0\x82\xf0}\xf0}\xf0`\xf0O\xf0K\xf0=\xf0/\xf0!\xf0\x1c\xf0\x0c\xf0\x0f\xf0\xf7\xef\xe9\xef\xe4\xef\xc4\xef\xcc\xef\xbb\xef\xb0\xef\x9f\xef\x91\xef\x87\xefq\xefu\xef_\xefN\xefN\xef<\xef2\xef/\xef\x12\xef\r\xef\x03\xef\xf7\xee\xdc\xee\xe5\xee\xce\xee\xc5\xee\xbb\xee\xb1\xee\xa9\xee\x98\xee}\xee~\xeep\xee\\\xeeq\xeeY\xeeI\xeeH\xee+\xee7\xee)\xee\x16\xee\x13\xee\x06\xee\xf2\xed\xe9\xed\xdb\xed\xc7\xed\xd0\xed\xbe\xed\xbf\xed\x9f\xed\x97\xed\x90\xed\x87\xed\x1f\xf4[\xf8\xd4\xf8\a\xf8)\xf7i\xf8\x82\xf8\xcf\xf7\xa4\xf6\xc8\xf7%\xf7b\xf6\a\xf7\xd2\xf6\xe7\xf6)\xf6\xe9\xf6\xdf\xf6*\xf6\x1c\xf6k\xf6\xd1\xec\xf1\xeb\xf7\xeb\x0c\xec\x15\xec\x10\xec\x0c\xec\x0f\xec\x0f\xec\x0c\xec\xf8\xeb\xf1\xeb\xe0\xeb\xdb\xeb\xd9\xeb\xd8\xeb\xcb\xeb\xc3\xeb\x9f\xeb\xa0\xeb\xa4\xeb\x90\xeb\x9b\xeb\x93\xeb\x83\xebi\xebR\xebi\xebY\xebW\xebM\xeb1\xeb3\xeb,\xeb\x16\xeb\x14\xeb\n\xeb\xff\xea\xed\xea\xd7\xea\xe9\xea\xc8\xea\xcc\xea\xcf\xea\xbd\xea\xba\xea\xa5\xea\x99\xea\xb9\xea\x91\xea\x81\xea\x86\xeas\xeae\xea_\xeaV\xeaZ\xeaG\xea:\xeaC\xea%\xea#\xea\x17\xea\a\xea\x11\xea\b\xea\x06\xea\xf2\xe9\xe4\xe9\xd0\xe9\xd4\xe9\xbd\xe9\xcd\xe9\xbb\xe9\xa5\xe9\xa9\xe9\xa8\xe9\x8d\xe9\x90\xe9\x81\xe9\x8f\xe9}\xe9p\xe9j\xe9X\xe9G\xe9F\xe99\xe97\xe92\xe9\x1c\xe9\x18\xe9\x0f\xe9\x05\xe9\a\xe9\xf9\xe8\xeb\xe8\xf4\xe8\xeb\xe8\xda\xe8\xd8\xe8\xb6\xe8\xba\xe8\xc5\xe8\x97\xe8\xad\xe8\xaa\xe8\x81\xe8u\xe8\x84\xe8\x98\xe8i\xe8v\xe8c\xe8C\xe8T\xe8R\xe8,\xe8H\xe8?\xe8*\xe8\"\xe8\x0f\xe8\x04\xe8\x00\xe8\a\xe8\x05\xe8\xea\xe7\xd1\xe7\xd2\xe7\xdf\xe7\xc4\xe7\xc4\xe7\xbc\xe7\xb2\xe7\xad\xe7\xa1\xe7\x88\xe7\xb3\xe7\x93\xe7\xa5\xe7k\xe7^\xe7u\xe7W\xe7E\xe7R\xe7R\xe7#\xe76\xe71\xe7-\xe7\x17\xe7\x17\xe7\x0c\xe7\xfa\xe6\xfe\xe6\xfa\xe6\xf3\xe6\xde\xe6\xe5\xe6\xe9\xe6\xd0\xe6\xcb\xe6\xb6\xe6\xbe\xe6\xa6\xe6\xa0\xe6\x9c\xe6\x8b\xe6\x90\xe6\x83\xe6\x8c\xe6t\xe6s\xe6m\xe6Z\xe6W\xe6?\xe6E\xe6T\xe61\xe6+\xe6#\xe6\x10\xe6\x12\xe6\x10\xe6\x1b\xe6\r\xe6\t\xe6\xe0\xe5\xd9\xe5\xd7\xe5\xda\xe5\xdd\xe5\xce\xe5\xc4\xe5\xa4\xe5\xc8\xe5\xa7\xe5\x9e\xe5\x9d\xe5\x8e\xe5\x97\xe5\x8f\xe5q\xe5c\xe5g\xe5e\xe5V\xe5R\xe5J\xe5>\xe5;\xe5-\xe5A\xe5\x1c\xe5\x05\xe5\r\xe5\x0c\xe5\a\xe5\x03\xe5\xe9\xe4\xe6\xe4\xdf\xe4\xdb\xe4\xc5\xe4\xd5\xe4\xc7\xe4\xb9\xe4\xaa\xe4\x9f\xe4\x9f\xe4\x8e\xe4\x92\xe4w\xe4k\xe4}\xe4u\xe4^\xe4W\xe4K\xe4?\xe4L\xe4@\xe4%\xe4\"\xe4\x1b\xe4\x1d\xe4\x10\xe4\x02\xe4\x04\xe4\xfd\xe3\xf2\xe3\xeb\xe3\xe5\xe3\xd3\xe3\xc7\xe3\xcd\xe3\xb0\xe3\xad\xe3\xc1\xe3\xb2\xe3\x9d\xe3\x92\xe3\x8e\xe3\x89\xe3\x82\xe3l\xe3k\xe3{\xe3m\xe3P\xe3J\xe3D\xe3/\xe38\xe31\xe3&\xe3 \xe3\x0f\xe3\b\xe3\x10\xe3\t\xe3\xe0\xe2\xe0\xe2\xe3\xe2\xdb\xe2\xcf\xe2\xc7\xe2\xbe\xe2\xb9\xe2\xa8\xe2\xae\xe2\x9f\xe2\x99\xe2}\xe2\x88\xe2w\xe2j\xe2f\xe2E\xe2O\xe2R\xe2L\xe23\xe2E\xe2\x17\xe2\"\xe2\x1c\xe2\x10\xe2\x0c\xe2\xe9\xe1\xd5\xe1\xf1\xe1\xf6\xe1\xe7\xe1\xde\xe1\xb7\xe1\xb1\xe1\xb9\xe1\x9e\xe1\xa6\xe1\x94\xe1\x87\xe1{\xe1\x80\xe1k\xe1r\xe1a\xe1S\xe1D\xe1E\xe1=\xe1,\xe1\x1f\xe1\x1d\xe1\x1d\xe1\x10\xe1\a\xe1\xf3\xe0\xeb\xe0\xca\xe0\xc9\xe0\xd7\xe0\xc9\xe0\xab\xe0\xa8\xe0\x9d\xe0\xaa\xe0\xa2\xe0\xa3\xe0r\xe0s\xe0g\xe0e\xe0a\xe0Y\xe0C\xe0?\xe0<\xe0\x1e\xe0+\xe0\x1d\xe0\x10\xe0\n\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0\x00\xe0"
    bin = bin.encode('latin-1')  # Convert to bytes
    data = np.frombuffer(bin, dtype='<i2')  # Interpret as little-endian int16
    for value in bin:
        if isinstance(value, bytes):
            try:
                # Interpret the byte string as little-endian int16 values
                data = np.frombuffer(value, dtype='<i2')
            except Exception as e:
                print(f"Error decoding binary field: {e}")
                continue

    y = np.frombuffer(data, dtype='<i2')
    print(f"Signal length: {len(y)}")

    print(current(y, sampling_rate=5_000_000, f_corner=4000, peak_fraction=0.9))